# 运行时数据区域

线程私有的：

+ 程序计数器
+ 虚拟机栈
+ 本地方法栈

线程共享的：

+ 堆
+ 方法区
+ 直接内存

## 程序计数器

单线程中引导字节码解释器进行代码流程的控制，多线程中记录线程运行位置，以便切换线程之后知道上次运行位置。

随着线程的创建而创建，随着线程的死亡而死亡

唯一不会出现`OutOfMemoryError`的内存区域

## 虚拟机栈

JVM核心区域，所有方法调用(除本地方法)都需要通过栈实现。

栈由一个个栈帧组成，每个栈帧包含局部变量表，操作数栈，动态链接，方法返回地址。

局部变量表：包含编译时已知的8种数据类型和对象引用，（reference类型，指的是对象存放地址，可能是对象内存地址起始值）

操作数栈：存放方法执行过程中的中间计算结果

动态链接：提供一个方法调用其他方法的服务

**两种栈Error**

`StackOverFlowError`:如果栈内存不能动态调整大小，且当前线程请求的栈深度超过当前java虚拟机栈的最大深度时，抛出此异常

`OutOfMemoryError`：如果占内存可以进行动态调整大小，但在虚拟机栈申请更多内存时失败，抛出此异常

## 本地方法栈

为虚拟机需要的非java语言的本地方法服务，与虚拟机栈类似，也会抛出两种错误

## 堆

是java虚拟机所管理的内存最大的一块，Java堆是所有线程所共享的，在线程启动时创建，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例和数组都在这里分配内存。

Java堆是垃圾回收的主要区域，所以也称为GC堆。从垃圾回收的角度看，由于几乎所有的java堆都使用分代垃圾收集算法，所以堆也可以再细分为新生代和老年代，在java1.7及之前，堆分为新生代，老年代和永久代，**JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存** ，对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

## 方法区

只是规定了有这个运行时数据区域的一块逻辑区域，具体实现需要看虚拟机，不同的虚拟机有着不同的方法区实现

**方法区和永久代，元空间的关系**，就像接口和实现类之间的关系，方法区只是制定了一个标准，具体实现就是永久代和元空间，1.8之前是永久代，之后改为元空间。

**为什么要取消永久代？** 

> 1. 永久代的内存空间受虚拟机参数设置受限，且无法调整，元空间使用的是本地内存空间，受物理内存空间限制，这样导致内存溢出的概率会更小。
> 2. 元空间内存放的是类的元数据，永久代由于受参数限制，无法加载更多的类，元空间则没有这样的限制，所以元空间可以加载更多的类
> 3. 在JDK8，合并 HotSpot 和 JRockit 的代码时，JRockit 没有叫做永久代的东西，所以就废除的永久代

**方法区常用参数有哪些**

JDK1.8之前使用永久代

```java
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen

```

JDK1.8之后使用元空间

```java
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```

元空间与永久代不同的是元空间不设置上线，则创建过多的类会导致耗尽系统资源

## 运行时常量池

将编译后的类的信息放入方法区中，是方法区的一部分

动态的获取类的信息，包括：class文件原信息描述、编译后的代码数据、引用类型数据、类文件常量池等

在类加载完后，将每个class常量池中的符号引用值转存至运行时常量池中，类在解析之后将符号应用转为直接应用与全局常量池中的数值保持一致

## 字符串常量池

是JVM为了提高性能和减少内存消耗针对String类专门开辟的一块空间，主要目的是为了避免字符串的重复创建

HotSpot 虚拟机中字符串常量池的实现是 `src/hotspot/share/classfile/stringTable.cpp` ,`StringTable` 本质上就是一个`HashSet<String>` ,容量为 `StringTableSize`（可以通过 `-XX:StringTableSize` 参数来设置）。

**`StringTable` 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。**

**JDK 1.7 为什么要将字符串常量池移动到堆中？**

GC在方法区中的收集效率太低

## 直接内存

是一块特殊区域，不在java堆或者方法区中分配，而是通过JNI的方式在本地内存上分配的

JNI是方便java代码调用本地使用其他语言编译的方法或给其他语言编译的方法调用java方法、

# HotSpot 虚拟机对象探秘

## 对象的创建

**Step1：类加载检查**

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

**Step2：分配内存**

在完成类加载检查之后需要给类分配内存空间，分配方式有两种：**指针碰撞**，**空闲列表**。使用哪种分配方式由java堆是否规整决定，而java堆是否规整由GC是否带有压缩整理功能决定

**内存分配的两种方式**

+ 指针碰撞
  + 适用场合：堆内存规整的情况下
  + 原理：用过的内存放在一边，没用过的放在一边，中间分界线有一个指针，只需要向没用过的内存方向移动对象内存大小即可完成分配
  + 使用该方式的GC：Sreial，ParNew
+ 空闲列表
  + 适用场合：堆内存不规整的情况下
  + 原理：将用过的内存和没用过的内存用一张表记录下来，根据表中没用过的内存取一块适当大小给对象分配内存，最后更新记录表
  + 适用该方式的GC：CMS

**内存分配并发问题**



