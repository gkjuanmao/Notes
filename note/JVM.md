# Java内存区域详解

## 运行时数据区域

线程私有的：

+ 程序计数器
+ 虚拟机栈
+ 本地方法栈

线程共享的：

+ 堆
+ 方法区
+ 直接内存

### 程序计数器

单线程中引导字节码解释器进行代码流程的控制，多线程中记录线程运行位置，以便切换线程之后知道上次运行位置。

随着线程的创建而创建，随着线程的死亡而死亡。

唯一不会出现`OutOfMemoryError`的内存区域。

### 虚拟机栈

JVM核心区域，所有方法调用(除本地方法)都需要通过栈实现。

栈由一个个栈帧组成，每个栈帧包含局部变量表，操作数栈，动态链接，方法返回地址。

局部变量表：包含编译时已知的8种数据类型和对象引用，（reference类型，指的是对象存放地址，可能是对象内存地址起始值）。

操作数栈：存放方法执行过程中的中间计算结果。

动态链接：提供一个方法调用其他方法的服务。

**两种栈Error**

`StackOverFlowError`:如果栈内存不能动态调整大小，且当前线程请求的栈深度超过当前java虚拟机栈的最大深度时，抛出此异常。

`OutOfMemoryError`：如果占内存可以进行动态调整大小，但在虚拟机栈申请更多内存时失败，抛出此异常。

### 本地方法栈

为虚拟机需要的非java语言的本地方法服务，与虚拟机栈类似，也会抛出两种错误。

### 堆

是java虚拟机所管理的内存最大的一块，Java堆是所有线程所共享的，在线程启动时创建，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例和数组都在这里分配内存。

Java堆是垃圾回收的主要区域，所以也称为GC堆。从垃圾回收的角度看，由于几乎所有的java堆都使用分代垃圾收集算法，所以堆也可以再细分为新生代和老年代，在java1.7及之前，堆分为新生代，老年代和永久代，**JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存** ，对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

### 方法区

只是规定了有这个运行时数据区域的一块逻辑区域，具体实现需要看虚拟机，不同的虚拟机有着不同的方法区实现。

**方法区和永久代，元空间的关系**，就像接口和实现类之间的关系，方法区只是制定了一个标准，具体实现就是永久代和元空间，1.8之前是永久代，之后改为元空间。

**为什么要取消永久代？** 

> 1. 永久代的内存空间受虚拟机参数设置受限，且无法调整，元空间使用的是本地内存空间，受物理内存空间限制，这样导致内存溢出的概率会更小。
> 2. 元空间内存放的是类的元数据，永久代由于受参数限制，无法加载更多的类，元空间则没有这样的限制，所以元空间可以加载更多的类。
> 3. 在JDK8，合并 HotSpot 和 JRockit 的代码时，JRockit 没有叫做永久代的东西，所以就废除的永久代。

**方法区常用参数有哪些**

JDK1.8之前使用永久代

```java
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen

```

JDK1.8之后使用元空间

```java
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```

元空间与永久代不同的是元空间不设置上线，则创建过多的类会导致耗尽系统资源。

### 运行时常量池

将编译后的类的信息放入方法区中，是方法区的一部分。

动态的获取类的信息，包括：class文件原信息描述、编译后的代码数据、引用类型数据、类文件常量池等。

在类加载完后，将每个class常量池中的符号引用值转存至运行时常量池中，类在解析之后将符号应用转为直接应用与全局常量池中的数值保持一致。

### 字符串常量池

是JVM为了提高性能和减少内存消耗针对String类专门开辟的一块空间，主要目的是为了避免字符串的重复创建。

HotSpot 虚拟机中字符串常量池的实现是 `src/hotspot/share/classfile/stringTable.cpp` ,`StringTable` 本质上就是一个`HashSet<String>` ,容量为 `StringTableSize`（可以通过 `-XX:StringTableSize` 参数来设置）。

**`StringTable` 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。**

**JDK 1.7 为什么要将字符串常量池移动到堆中？**

GC在方法区中的收集效率太低。

### 直接内存

是一块特殊区域，不在java堆或者方法区中分配，而是通过JNI的方式在本地内存上分配的。

JNI是方便java代码调用本地使用其他语言编译的方法或给其他语言编译的方法调用java方法。

## HotSpot 虚拟机对象探秘

### 对象的创建

#### **Step1：类加载检查**

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

#### **Step2：分配内存**

在完成类加载检查之后需要给类分配内存空间，分配方式有两种：**指针碰撞**，**空闲列表**。使用哪种分配方式由java堆是否规整决定，而java堆是否规整由GC是否带有压缩整理功能决定。

**内存分配的两种方式**

+ 指针碰撞
  + 适用场合：堆内存规整的情况下。
  + 原理：用过的内存放在一边，没用过的放在一边，中间分界线有一个指针，只需要向没用过的内存方向移动对象内存大小即可完成分配。
  + 使用该方式的GC：Sreial，ParNew。
+ 空闲列表
  + 适用场合：堆内存不规整的情况下。
  + 原理：将用过的内存和没用过的内存用一张表记录下来，根据表中没用过的内存取一块适当大小给对象分配内存，最后更新记录表。
  + 适用该方式的GC：CMS。

**内存分配并发问题**

+ CAS+失败重试：CAS是一种乐观锁的实现方式，乐观锁实现方式是每次操作不加锁，假设没有冲突去完成某件事，如果冲突就失败，直到成功为止，**虚拟机采用每次冲突失败重试的方式保证更新操作的原子性。**
+ TLAB：为每个线程预先在Eden区预留一部分未使用内存，在分配内存时如果线程中的对象大小没有超过预留的内存大小则直接分配，如果大于则采用CAS+的方式进行分配。

#### **Step3：初始化零值**

内存分配完成后将除对象头之外的所有内存进行初始化，以便在java代码中不需要初始化即可直接使用。

#### **Step4：设置对象头**

初始化完成后对对象进行必要的设置，将对象的一些信息记录在对象头中，比如对象的hash码，对象的年代，对象是哪个类的实例等，如果是数组对象还会在对象头中记录数组长度。

#### **Step5：执行init方法**

此时虚拟机会按照程序猿的意愿初始化对象，此时一个真正可用的对象才算完整的创建出来。

### 对象的内存布局

对象在内存中的布局包括对象头、实例数据和对齐填充。

**对象头：**对象头中存储了对象是很多java内部的信息,如hash码,对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间等,Java对象头一般占有2个机器码，包括Mark Word和Class Pointer。

**实例数据：**是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。

**对齐填充：**无实际意义，仅仅为占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

### 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**、**直接指针**。

# JVM垃圾回收详解

## 堆的基本结构

1. 新生代
2. 老年代
3. 元空间（Java8之后）

## 内存分配和回收原则

### 对象优先在Eden区域分配

对象的内存分配优先在Eden区域进行，当Eden空间不够时会发起一次Minor GC，在GC期间发现创建的对象无法移入Survivor区域，则采取**分配担保机制**，将过大的对象提前移入老年代区域，执行完成Minor GC之后后面创建的对象如果可以在Eden中则还是会分配在Eden中。

### 大对象直接移入老年代区

大对象直接进入老年代区是为了避免分配担保机制导致的重复复制带来效率的降低。

### 长期存活的对象进入老年代区

在Eden区中分配的对象如果经过一次Minor GC之后仍能存活，并且能被Survivor所容纳，则将对象移至Survivor区（S0,S1），并将对象年龄设置为1。

对象在Survivor中每存活过一次Minor GC，就将年龄增加1，当年龄到一定值时，就会被移入老年代。

对象移入到老年代的年龄阈值可以通过参数`-XX:MaxTenuringThreshold`来设置

>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 `-XX:TargetSurvivorRatio=percent` 来设置，参见 [issue1199open in new window](https://github.com/Snailclimb/JavaGuide/issues/1199) ），取这个年龄和 `MaxTenuringThreshold` 中更小的一个值，作为新的晋升年龄阈值。

默认晋升年龄并不都是15，CMS的就是6

### 主要进行GC的区域

部分收集(Partial GC)：

+ 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
+ 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
+ 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。

## 死亡对象判断方法

堆中存放着大量的实例，如果要进行一次GC，那么就需要知道这些实例是否还被以任何途径所引用。

### 引用计数法

在对象中添加一个计数器，每当其他地方引用对象时计数器加一，引用失效就减一，当进行GC时如果计数器为0，则回收这个对象。

**优点：**简单，效率高。

**缺点：**如果有循环引用的情况则无法进行GC。

### 可达性分析算法

这个算法的基本思想就是将一系列的称为“GC Roots”的对象当做起点，从这些节点向下搜索，节点所走过的路径称为引用链，当一个对象和GC Roots之间没有任何引用链相连的话，就证明此对象不可达，需要被回收。

**哪些对象可以作为 GC Roots 呢？**

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

**对象可以被回收，就代表一定会被回收吗？**

即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize` 方法。当对象没有覆盖 `finalize` 方法，或 `finalize` 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

### 引用类型总结

**1．强引用（StrongReference）**

以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

**2．软引用（SoftReference）**

如果一个对象只具有软引用，那就类似于**可有可无的生活用品**。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

**3．弱引用（WeakReference）**

如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

**4．虚引用（PhantomReference）**

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

