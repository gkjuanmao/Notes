# 运行时数据区域

线程私有的：

+ 程序计数器
+ 虚拟机栈
+ 本地方法栈

线程共享的：

+ 堆
+ 方法区
+ 直接内存

## 程序计数器

单线程中引导字节码解释器进行代码流程的控制，多线程中记录线程运行位置，以便切换线程之后知道上次运行位置。

随着线程的创建而创建，随着线程的死亡而死亡

唯一不会出现`OutOfMemoryError`的内存区域

## 虚拟机栈

JVM核心区域，所有方法调用(除本地方法)都需要通过栈实现。

栈由一个个栈帧组成，每个栈帧包含局部变量表，操作数栈，动态链接，方法返回地址。

局部变量表：包含编译时已知的8种数据类型和对象引用，（reference类型，指的是对象存放地址，可能是对象内存地址起始值）

操作数栈：存放方法执行过程中的中间计算结果

动态链接：提供一个方法调用其他方法的服务

### 两种栈Error

`StackOverFlowError`:如果栈内存不能动态调整大小，且当前线程请求的栈深度超过当前java虚拟机栈的最大深度时，抛出此异常

`OutOfMemoryError`：如果占内存可以进行动态调整大小，但在虚拟机栈申请更多内存时失败，抛出此异常

## 本地方法栈

为虚拟机需要的非java语言的本地方法服务，与虚拟机栈类似，也会抛出两种错误

## 堆

是java虚拟机所管理的内存最大的一块，Java堆是所有线程所共享的，在线程启动时创建，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例和数组都在这里分配内存。

Java堆是垃圾回收的主要区域，所以也称为GC堆。从垃圾回收的角度看，由于几乎所有的java堆都使用分代垃圾收集算法，所以堆也可以再细分为新生代和老年代，在java1.7及之前，堆分为新生代，老年代和永久代，**JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存** ，对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

## 方法区


